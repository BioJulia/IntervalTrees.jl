var documenterSearchIndex = {"docs":
[{"location":"man/intersection/#Intersection","page":"Intersection","title":"Intersection","text":"","category":"section"},{"location":"man/intersection/","page":"Intersection","title":"Intersection","text":"The primary thing an IntervalTree offers over a Dict is the ability to efficiently find intersections. IntervalTrees supports searching and iterating over intersections between two trees or between a tree and a single interval.","category":"page"},{"location":"man/intersection/","page":"Intersection","title":"Intersection","text":"intersect(t::IntervalTree, query::(Any, Any)): Return an iterator over every interval in t that intersects query.","category":"page"},{"location":"man/intersection/","page":"Intersection","title":"Intersection","text":"intersect(t1::IntervalTree, t2::IntervalTree): Return an iterator over every pair of intersecting entries (interval1, interval2), where interval1 is in t1 and interval2 is in t2.","category":"page"},{"location":"man/intersection/","page":"Intersection","title":"Intersection","text":"hasintersection(t::IntervalTree, position): Return true if position intersects some interval in t.","category":"page"},{"location":"man/iteration/#Iteration","page":"Iterating over intervals","title":"Iteration","text":"","category":"section"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"As with dictionaries, key/value pairs can be iterated through efficiently.","category":"page"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"    for x in xs\n        println(\"Interval $(x.first), $(x.last) has value $(x.value)\")\n    end","category":"page"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"Some other iteration functions are provided:","category":"page"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"from(t::IntervalTree, query): Return an iterator thats iterates through every key/value pair with an end position >= to query.","category":"page"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"keys(t::IntervalTree): Return an iterator that iterates through every interval key in the tree.","category":"page"},{"location":"man/iteration/","page":"Iterating over intervals","title":"Iterating over intervals","text":"values(t::IntervalTree): Return an iterator that iterates through every value in the tree.","category":"page"},{"location":"man/dict/#Standard-Dictionary-Operations","page":"Dictionary Operations","title":"Standard Dictionary Operations","text":"","category":"section"},{"location":"man/dict/","page":"Dictionary Operations","title":"Dictionary Operations","text":"IntervalTree implements all the standard dictionary operations. You can use it as an efficient way to map (K, K) tuples to values.","category":"page"},{"location":"man/dict/","page":"Dictionary Operations","title":"Dictionary Operations","text":"using IntervalTrees\n\n# Create an interval tree mapping (Int, Int) intervals to Strings.\nxs = IntervalMap{Int, String}()\n\n# Insert values\nxs[(1,100)] = \"Low\"\nxs[(101,1000)] = \"Medium\"\nxs[(1001,10000)] = \"High\"\n\n# Search for values\nprintln(xs[(1001,10000)]) # prints \"High\"\n\n# Get a value, returning a default value if not found\nprintln(get(xs, (10001, 100000), \"Not found\")) # prints \"Not found\"\n\n# Set a value if it's not already present\nprintln(set(xs, (10001, 100000), \"Not found\"))\n\n# Delete values\ndelete!(xs, (1,100))\n","category":"page"},{"location":"man/insertion/#Creating-IntervalTrees-and-inserting-intervals","page":"Creating IntervalTrees","title":"Creating IntervalTrees & inserting intervals","text":"","category":"section"},{"location":"man/insertion/","page":"Creating IntervalTrees","title":"Creating IntervalTrees","text":"New intervals can be added to an IntervalTree with the push! function.","category":"page"},{"location":"man/insertion/","page":"Creating IntervalTrees","title":"Creating IntervalTrees","text":"xs = IntervalTree{Int, Interval{Int}}()\npush!(xs, Interval{Int}(500, 1000))","category":"page"},{"location":"man/insertion/","page":"Creating IntervalTrees","title":"Creating IntervalTrees","text":"A more efficient means of building the data structure by bulk insertion. If the intervals are knows up front and provided in a sorted array, an IntervalTree can be built extremely efficiently.","category":"page"},{"location":"man/insertion/","page":"Creating IntervalTrees","title":"Creating IntervalTrees","text":"intervals = Interval{Int}[]\n# construct a large array of intervals...\n\nsort!(intervals)\nxs = IntervalTree{Int, Interval{Int}}(intervals)","category":"page"},{"location":"#IntervalTrees","page":"Home","title":"IntervalTrees","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Latest Release) (Image: MIT License) (Image: Stable documentation) (Image: Lifecycle)","category":"page"},{"location":"#Description","page":"Home","title":"Description","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalTrees provides the type: IntervalTree{K, V}. It implements an associative container mapping (K, K) pairs to to values of type V. K may be any ordered type, but only pairs (a, b) where a â‰¤ b can be stored. In other words they are associative contains that map intervals to values.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can install the IntervalTrees package from the Julia REPL. Press ] to enter pkg mode, then enter the following command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"add IntervalTrees","category":"page"},{"location":"","page":"Home","title":"Home","text":"If you are interested in the cutting edge of the development, please check out the master branch to try new features before release.","category":"page"},{"location":"#Testing","page":"Home","title":"Testing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"IntervalTrees is tested against Julia 0.7-1.X on Linux, OS X, and Windows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Latest build status:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: Unit tests) (Image: Documentation) (Image: codecov)","category":"page"},{"location":"#Contributing","page":"Home","title":"Contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We appreciate contributions from users including reporting bugs, fixing issues, improving performance and adding new features.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Take a look at the contributing files detailed contributor and maintainer guidelines, and code of conduct.","category":"page"},{"location":"#Financial-contributions","page":"Home","title":"Financial contributions","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"We also welcome financial contributions in full transparency on our open collective. Anyone can file an expense. If the expense makes sense for the development of the community, it will be \"merged\" in the ledger of our open collective by the core contributors and the person who filed the expense will be reimbursed.","category":"page"},{"location":"#Backers-and-Sponsors","page":"Home","title":"Backers & Sponsors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Thank you to all our backers and sponsors!","category":"page"},{"location":"","page":"Home","title":"Home","text":"Love our work and community? Become a backer.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: backers)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Does your company use BioJulia? Help keep BioJulia feature rich and healthy by sponsoring the project Your logo will show up here with a link to your website.","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: ) (Image: )","category":"page"},{"location":"#Questions?","page":"Home","title":"Questions?","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have a question about contributing or using BioJulia software, come on over and chat to us on the Julia Slack workspace, or you can try the Bio category of the Julia discourse site.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"CurrentModule = IntervalTrees","category":"page"},{"location":"man/types/#Intervals-and-IntervalTrees","page":"Types","title":"Intervals & IntervalTrees","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"IntervalTrees exports an abstract type AbstractInterval{K}, in addition to two basic concrete interval types.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"AbstractInterval\nInterval\nIntervalValue","category":"page"},{"location":"man/types/#IntervalTrees.AbstractInterval","page":"Types","title":"IntervalTrees.AbstractInterval","text":"Types deriving from AbstractInterval{T} must have a first and last function each returning a value of type T, and first(i) <= last(i) must always be true.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#IntervalTrees.Interval","page":"Types","title":"IntervalTrees.Interval","text":"A basic interval.\n\n\n\n\n\n","category":"type"},{"location":"man/types/#IntervalTrees.IntervalValue","page":"Types","title":"IntervalTrees.IntervalValue","text":"An interval with some associated data.\n\n\n\n\n\n","category":"type"},{"location":"man/types/","page":"Types","title":"Types","text":"Intervals in this package are always treated as end-inclusive, similar to the Julia Range type.","category":"page"},{"location":"man/types/#IntervalTrees","page":"Types","title":"IntervalTrees","text":"","category":"section"},{"location":"man/types/","page":"Types","title":"Types","text":"The basic data structure implemented in this package is IntervalTree{K, V}, which stores intervals of type V, that have start and end positions of type K.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"IntervalMap{K, V} is a typealias for IntervalTree{K, IntervalValue{K, V}} to simplify associating data of type V with intervals.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Multiple data structures are refered to as \"interval trees\". What's implemented here is the data structure described in the Cormen, et al. \"Algorithms\" book, or what's refered to as an augmented tree in the wikipedia article. This sort of data structure is just an balanced search tree augmented with a field to keep track of the maximum interval end point in that node's subtree.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Many operations over two or more sets of intervals can be most efficiently implemented by jointly iterating over the sets in order. For example, finding all the intersecting intervals in two sets S and T can be implemented similarly to the merge function in mergesort in O(n+m) time.","category":"page"},{"location":"man/types/","page":"Types","title":"Types","text":"Thus a general purpose data structure should be optimized for fast in-order iteration while efficiently supporting other operations like insertion, deletion, and single intersection tests. A B+-tree is nicely suited to the task. Since all the intervals and values are stored in contiguous memory in the leaf nodes, and the leaf nodes augmented with sibling pointers, in-order traversal is exceedingly efficient compared to other balanced search trees, while other operations are comparable in performance.","category":"page"}]
}
